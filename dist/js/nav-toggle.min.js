/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/nav-toggle.js":
/*!******************************!*\
  !*** ./src/js/nav-toggle.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("(async () => {\n  const {\n    close,\n    open\n  } = await __webpack_require__.e(/*! import() | toggleWidgets */ \"toggleWidgets\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./nav-toggle/toggle-widgets */ \"./src/js/nav-toggle/toggle-widgets.js\", 23));\n  const NavToggle = await __webpack_require__.e(/*! import() | navToggleDropdown */ \"navToggleDropdown\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./nav-toggle/nav-toggle-dropdown */ \"./src/js/nav-toggle/nav-toggle-dropdown.js\", 23));\n  const NavToggleDropdown = NavToggle.default;\n  const BRANDING_ELEMENTS = {};\n  let MENU;\n  let MenuDropdown = {};\n\n  // Check what features on header branding region are on.\n  if (drupalSettings.hdbt.profile_dropdown === true) {\n    BRANDING_ELEMENTS.ProfileDropdown = 'profile';\n  }\n  if (drupalSettings.hdbt.search_dropdown === true) {\n    BRANDING_ELEMENTS.SearchDropdown = 'search';\n  }\n  if (drupalSettings.hdbt.otherlangs_dropdown === true) {\n    BRANDING_ELEMENTS.OtherLangsDropdown = 'otherlangs';\n  }\n  if (drupalSettings.hdbt.global_menu === true) {\n    MENU = await Promise.all(/*! import() | globalMenu */[__webpack_require__.e(\"vendors-node_modules_classnames_index_js-node_modules_mustache_mustache_mjs\"), __webpack_require__.e(\"globalMenu\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./nav-global/menu */ \"./src/js/nav-global/menu.js\"));\n    MenuDropdown = MENU.default;\n  } else {\n    BRANDING_ELEMENTS.CssMenuDropdownDropdown = 'cssmenu';\n  }\n  function isScrollable(element) {\n    return element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight;\n  }\n  const isMobile = () => window.matchMedia('(max-width: 768px)').matches; // Needs to be 768px as after that breakpoint user can scroll header almost offscreen, open menu accidentally and not be able to scroll back up.\n\n  const AllElements = BRANDING_ELEMENTS;\n  const keys = Object.keys(AllElements);\n  keys.forEach(key => {\n    const name = AllElements[key];\n    AllElements[key] = NavToggleDropdown();\n    AllElements[key].init({\n      name: `${name} dropdown`,\n      buttonSelector: `.js-${name}-button`,\n      targetSelector: `#${name}`,\n      onOpen: () => {\n        // Close all open menus before opening a new one.\n        keys.forEach(menuName => {\n          if (menuName !== key) {\n            AllElements[menuName].close();\n          }\n        });\n        if (Object.keys(MenuDropdown).length !== 0) {\n          MenuDropdown.close();\n        }\n        close();\n        if (key === 'SearchDropdown') {\n          // Focus search field on open.\n          window.setTimeout(() => document.querySelector('.header-search-wrapper input[type=\"search\"]')?.focus(), 10); // Delay focus until element is focusable\n        }\n      },\n\n      onClose: open\n    });\n  });\n  if (Object.keys(MenuDropdown).length !== 0) {\n    MenuDropdown.init({\n      onOpen: () => {\n        keys.forEach(key => {\n          AllElements[key].close();\n        });\n        close();\n      },\n      onClose: open\n    });\n  }\n\n  /**\n   * See if menu instance is open\n   *\n   * @return boolean\n   */\n\n  const isAnyMenuOpen = () => {\n    let isOpen = false;\n    keys.forEach(key => {\n      if (AllElements[key].isOpen()) {\n        isOpen = true;\n      }\n    });\n    if (Object.keys(MenuDropdown).length !== 0 && MenuDropdown.isOpen()) {\n      isOpen = true;\n    }\n    return isOpen;\n  };\n  const closeFromOutside = ({\n    target\n  }) => {\n    if (target.closest('.desktop-menu, .header-top') || target.closest('.header') === null) {\n      keys.forEach(key => {\n        AllElements[key].close();\n      });\n      if (Object.keys(MenuDropdown).length !== 0) {\n        MenuDropdown.close();\n      }\n      open();\n    }\n  };\n\n  /**\n   * Blocks body scroll events when full screen menus are open.\n   * @param e\n   * @return boolean\n   */\n\n  const blockBrandingScroll = e => {\n    // gesture actions are excluded\n    if (e.touches && e.touches.length > 1) {\n      return true;\n    }\n    const scrolledPanel = e.target.closest('.mmenu__panel--current, .nav-toggle-dropdown__content');\n    const preventBodyScrolling = isMobile() && isAnyMenuOpen() && (\n    // Don't scroll body from shared header\n    e.target.closest('.nav-toggle-dropdown') === null ||\n    // If element has no overflow, it has no overscroll containment.\n    // See overscroll-behavour CSS specs\n    scrolledPanel !== null && !isScrollable(scrolledPanel));\n    if (preventBodyScrolling) {\n      e.preventDefault();\n      e.stopPropagation();\n      return false;\n    }\n  };\n\n  /**\n   * Attach outside click listener to the whole header branding region area\n   * so that OtherLangs Menu and Mega menu\n   * can be closed when clicking outside of header branding region\n   */\n\n  // This used to load after DOM was loaded, but we added defer for the javascript.\n  document.addEventListener('click', closeFromOutside);\n\n  // Prevent body scroll through shared header element when full screen  menu is open.\n  const body = document.querySelector('body');\n  body.addEventListener('wheel', blockBrandingScroll, {\n    passive: false\n  });\n  body.addEventListener('scroll', blockBrandingScroll, {\n    passive: false\n  });\n  body.addEventListener('touchmove', blockBrandingScroll, {\n    passive: false\n  });\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RDtFQUNBLE1BQU1XLElBQUksR0FBS2pCLFFBQVEsQ0FBQ0MsYUFBYSxDQUFDLE1BQU0sQ0FBQztFQUM3Q2dCLElBQUksQ0FBQ0QsZ0JBQWdCLENBQUMsT0FBTyxFQUFFUCxtQkFBbUIsRUFBRTtJQUFFUyxPQUFPLEVBQUU7RUFBTSxDQUFDLENBQUM7RUFDdkVELElBQUksQ0FBQ0QsZ0JBQWdCLENBQUMsUUFBUSxFQUFFUCxtQkFBbUIsRUFBRTtJQUFFUyxPQUFPLEVBQUU7RUFBTSxDQUFDLENBQUM7RUFDeEVELElBQUksQ0FBQ0QsZ0JBQWdCLENBQUMsV0FBVyxFQUFFUCxtQkFBbUIsRUFBRTtJQUFFUyxPQUFPLEVBQUU7RUFBTSxDQUFDLENBQUM7QUFDN0UsQ0FBQyxFQUFFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZGJ0Ly4vc3JjL2pzL25hdi10b2dnbGUuanM/YmY5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIoYXN5bmMgKCkgPT4ge1xuICBjb25zdCB7Y2xvc2UsIG9wZW59ID0gYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwidG9nZ2xlV2lkZ2V0c1wiICovICcuL25hdi10b2dnbGUvdG9nZ2xlLXdpZGdldHMnKTtcbiAgY29uc3QgTmF2VG9nZ2xlID0gYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwibmF2VG9nZ2xlRHJvcGRvd25cIiAqLyAnLi9uYXYtdG9nZ2xlL25hdi10b2dnbGUtZHJvcGRvd24nKTtcbiAgY29uc3QgTmF2VG9nZ2xlRHJvcGRvd24gPSBOYXZUb2dnbGUuZGVmYXVsdDtcblxuICBjb25zdCBCUkFORElOR19FTEVNRU5UUyA9IHt9O1xuICBsZXQgTUVOVTtcbiAgbGV0IE1lbnVEcm9wZG93biA9IHt9O1xuXG4gIC8vIENoZWNrIHdoYXQgZmVhdHVyZXMgb24gaGVhZGVyIGJyYW5kaW5nIHJlZ2lvbiBhcmUgb24uXG4gIGlmIChkcnVwYWxTZXR0aW5ncy5oZGJ0LnByb2ZpbGVfZHJvcGRvd24gPT09IHRydWUpIHtcbiAgICBCUkFORElOR19FTEVNRU5UUy5Qcm9maWxlRHJvcGRvd24gPSAncHJvZmlsZSc7XG4gIH1cblxuICBpZiAoZHJ1cGFsU2V0dGluZ3MuaGRidC5zZWFyY2hfZHJvcGRvd24gPT09IHRydWUpIHtcbiAgICBCUkFORElOR19FTEVNRU5UUy5TZWFyY2hEcm9wZG93biA9ICdzZWFyY2gnO1xuICB9XG5cbiAgaWYgKGRydXBhbFNldHRpbmdzLmhkYnQub3RoZXJsYW5nc19kcm9wZG93biA9PT0gdHJ1ZSkge1xuICAgIEJSQU5ESU5HX0VMRU1FTlRTLk90aGVyTGFuZ3NEcm9wZG93biA9ICdvdGhlcmxhbmdzJztcbiAgfVxuXG4gIGlmIChkcnVwYWxTZXR0aW5ncy5oZGJ0Lmdsb2JhbF9tZW51ID09PSB0cnVlKSB7XG4gICAgTUVOVSA9IGF3YWl0IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcImdsb2JhbE1lbnVcIiAqLyAnLi9uYXYtZ2xvYmFsL21lbnUnKTtcbiAgICBNZW51RHJvcGRvd24gPSBNRU5VLmRlZmF1bHQ7XG4gIH0gZWxzZSB7XG4gICAgQlJBTkRJTkdfRUxFTUVOVFMuQ3NzTWVudURyb3Bkb3duRHJvcGRvd24gPSAnY3NzbWVudSc7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Njcm9sbGFibGUoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFdpZHRoID4gZWxlbWVudC5jbGllbnRXaWR0aCB8fCBlbGVtZW50LnNjcm9sbEhlaWdodCA+IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICB9XG5cbiAgY29uc3QgaXNNb2JpbGUgPSAoKSA9PiB3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC13aWR0aDogNzY4cHgpJykubWF0Y2hlczsgLy8gTmVlZHMgdG8gYmUgNzY4cHggYXMgYWZ0ZXIgdGhhdCBicmVha3BvaW50IHVzZXIgY2FuIHNjcm9sbCBoZWFkZXIgYWxtb3N0IG9mZnNjcmVlbiwgb3BlbiBtZW51IGFjY2lkZW50YWxseSBhbmQgbm90IGJlIGFibGUgdG8gc2Nyb2xsIGJhY2sgdXAuXG5cbiAgY29uc3QgQWxsRWxlbWVudHMgPSBCUkFORElOR19FTEVNRU5UUztcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoQWxsRWxlbWVudHMpO1xuXG4gIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IEFsbEVsZW1lbnRzW2tleV07XG4gICAgQWxsRWxlbWVudHNba2V5XSA9IE5hdlRvZ2dsZURyb3Bkb3duKCk7XG4gICAgQWxsRWxlbWVudHNba2V5XS5pbml0KHtcbiAgICAgIG5hbWU6IGAke25hbWV9IGRyb3Bkb3duYCxcbiAgICAgIGJ1dHRvblNlbGVjdG9yOiBgLmpzLSR7bmFtZX0tYnV0dG9uYCxcbiAgICAgIHRhcmdldFNlbGVjdG9yOiBgIyR7bmFtZX1gLFxuICAgICAgb25PcGVuOiAoKSA9PiB7XG4gICAgICAgIC8vIENsb3NlIGFsbCBvcGVuIG1lbnVzIGJlZm9yZSBvcGVuaW5nIGEgbmV3IG9uZS5cbiAgICAgICAga2V5cy5mb3JFYWNoKChtZW51TmFtZSkgPT4ge1xuICAgICAgICAgIGlmIChtZW51TmFtZSAhPT0ga2V5KSB7XG4gICAgICAgICAgICBBbGxFbGVtZW50c1ttZW51TmFtZV0uY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoTWVudURyb3Bkb3duKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBNZW51RHJvcGRvd24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZSgpO1xuICAgICAgICBpZiAoa2V5ID09PSAnU2VhcmNoRHJvcGRvd24nKSB7XG4gICAgICAgICAgLy8gRm9jdXMgc2VhcmNoIGZpZWxkIG9uIG9wZW4uXG4gICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmhlYWRlci1zZWFyY2gtd3JhcHBlciBpbnB1dFt0eXBlPVwic2VhcmNoXCJdJyk/LmZvY3VzKCksIDEwKTsgLy8gRGVsYXkgZm9jdXMgdW50aWwgZWxlbWVudCBpcyBmb2N1c2FibGVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xvc2U6IG9wZW5cbiAgICB9KTtcbiAgfSk7XG4gIGlmIChPYmplY3Qua2V5cyhNZW51RHJvcGRvd24pLmxlbmd0aCAhPT0gMCkge1xuICAgIE1lbnVEcm9wZG93bi5pbml0KHtcbiAgICAgIG9uT3BlbjogKCkgPT4ge1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIEFsbEVsZW1lbnRzW2tleV0uY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9LFxuICAgICAgb25DbG9zZTogb3BlblxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBtZW51IGluc3RhbmNlIGlzIG9wZW5cbiAgICpcbiAgICogQHJldHVybiBib29sZWFuXG4gICAqL1xuXG4gIGNvbnN0IGlzQW55TWVudU9wZW4gPSAoKSA9PiB7XG4gICAgbGV0IGlzT3BlbiA9IGZhbHNlO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChBbGxFbGVtZW50c1trZXldLmlzT3BlbigpKSB7XG4gICAgICAgIGlzT3BlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoTWVudURyb3Bkb3duKS5sZW5ndGggIT09IDAgJiYgTWVudURyb3Bkb3duLmlzT3BlbigpKSB7XG4gICAgICBpc09wZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBpc09wZW47XG4gIH07XG5cbiAgY29uc3QgY2xvc2VGcm9tT3V0c2lkZSA9ICh7IHRhcmdldCB9KSA9PiB7XG4gICAgaWYgKHRhcmdldC5jbG9zZXN0KCcuZGVza3RvcC1tZW51LCAuaGVhZGVyLXRvcCcpIHx8IHRhcmdldC5jbG9zZXN0KCcuaGVhZGVyJykgPT09IG51bGwpIHtcbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIEFsbEVsZW1lbnRzW2tleV0uY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKE1lbnVEcm9wZG93bikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIE1lbnVEcm9wZG93bi5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgb3BlbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQmxvY2tzIGJvZHkgc2Nyb2xsIGV2ZW50cyB3aGVuIGZ1bGwgc2NyZWVuIG1lbnVzIGFyZSBvcGVuLlxuICAgKiBAcGFyYW0gZVxuICAgKiBAcmV0dXJuIGJvb2xlYW5cbiAgICovXG5cbiAgY29uc3QgYmxvY2tCcmFuZGluZ1Njcm9sbCA9IChlKSA9PiB7XG4gICAgLy8gZ2VzdHVyZSBhY3Rpb25zIGFyZSBleGNsdWRlZFxuICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+MSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsZWRQYW5lbCA9IGUudGFyZ2V0LmNsb3Nlc3QoJy5tbWVudV9fcGFuZWwtLWN1cnJlbnQsIC5uYXYtdG9nZ2xlLWRyb3Bkb3duX19jb250ZW50Jyk7XG4gICAgY29uc3QgcHJldmVudEJvZHlTY3JvbGxpbmcgPVxuICAgICAgaXNNb2JpbGUoKSAmJlxuICAgICAgaXNBbnlNZW51T3BlbigpICYmXG4gICAgICAvLyBEb24ndCBzY3JvbGwgYm9keSBmcm9tIHNoYXJlZCBoZWFkZXJcbiAgICAgIChlLnRhcmdldC5jbG9zZXN0KCcubmF2LXRvZ2dsZS1kcm9wZG93bicpID09PSBudWxsIHx8XG4gICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIG5vIG92ZXJmbG93LCBpdCBoYXMgbm8gb3ZlcnNjcm9sbCBjb250YWlubWVudC5cbiAgICAgICAgLy8gU2VlIG92ZXJzY3JvbGwtYmVoYXZvdXIgQ1NTIHNwZWNzXG4gICAgICAgIChzY3JvbGxlZFBhbmVsICE9PSBudWxsICYmICFpc1Njcm9sbGFibGUoc2Nyb2xsZWRQYW5lbCkpKTtcblxuICAgIGlmIChwcmV2ZW50Qm9keVNjcm9sbGluZykge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQXR0YWNoIG91dHNpZGUgY2xpY2sgbGlzdGVuZXIgdG8gdGhlIHdob2xlIGhlYWRlciBicmFuZGluZyByZWdpb24gYXJlYVxuICAgKiBzbyB0aGF0IE90aGVyTGFuZ3MgTWVudSBhbmQgTWVnYSBtZW51XG4gICAqIGNhbiBiZSBjbG9zZWQgd2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIGhlYWRlciBicmFuZGluZyByZWdpb25cbiAgICovXG5cbiAgLy8gVGhpcyB1c2VkIHRvIGxvYWQgYWZ0ZXIgRE9NIHdhcyBsb2FkZWQsIGJ1dCB3ZSBhZGRlZCBkZWZlciBmb3IgdGhlIGphdmFzY3JpcHQuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xvc2VGcm9tT3V0c2lkZSk7XG5cbiAgLy8gUHJldmVudCBib2R5IHNjcm9sbCB0aHJvdWdoIHNoYXJlZCBoZWFkZXIgZWxlbWVudCB3aGVuIGZ1bGwgc2NyZWVuICBtZW51IGlzIG9wZW4uXG4gIGNvbnN0IGJvZHkgPSAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgYm9keS5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGJsb2NrQnJhbmRpbmdTY3JvbGwsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgYmxvY2tCcmFuZGluZ1Njcm9sbCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBibG9ja0JyYW5kaW5nU2Nyb2xsLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xufSkoKTtcbiJdLCJuYW1lcyI6WyJjbG9zZSIsIm9wZW4iLCJOYXZUb2dnbGUiLCJOYXZUb2dnbGVEcm9wZG93biIsImRlZmF1bHQiLCJCUkFORElOR19FTEVNRU5UUyIsIk1FTlUiLCJNZW51RHJvcGRvd24iLCJkcnVwYWxTZXR0aW5ncyIsImhkYnQiLCJwcm9maWxlX2Ryb3Bkb3duIiwiUHJvZmlsZURyb3Bkb3duIiwic2VhcmNoX2Ryb3Bkb3duIiwiU2VhcmNoRHJvcGRvd24iLCJvdGhlcmxhbmdzX2Ryb3Bkb3duIiwiT3RoZXJMYW5nc0Ryb3Bkb3duIiwiZ2xvYmFsX21lbnUiLCJDc3NNZW51RHJvcGRvd25Ecm9wZG93biIsImlzU2Nyb2xsYWJsZSIsImVsZW1lbnQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiaXNNb2JpbGUiLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsIkFsbEVsZW1lbnRzIiwia2V5cyIsIk9iamVjdCIsImZvckVhY2giLCJrZXkiLCJuYW1lIiwiaW5pdCIsImJ1dHRvblNlbGVjdG9yIiwidGFyZ2V0U2VsZWN0b3IiLCJvbk9wZW4iLCJtZW51TmFtZSIsImxlbmd0aCIsInNldFRpbWVvdXQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJmb2N1cyIsIm9uQ2xvc2UiLCJpc0FueU1lbnVPcGVuIiwiaXNPcGVuIiwiY2xvc2VGcm9tT3V0c2lkZSIsInRhcmdldCIsImNsb3Nlc3QiLCJibG9ja0JyYW5kaW5nU2Nyb2xsIiwiZSIsInRvdWNoZXMiLCJzY3JvbGxlZFBhbmVsIiwicHJldmVudEJvZHlTY3JvbGxpbmciLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJib2R5IiwicGFzc2l2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/nav-toggle.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	!function() {
/******/ 		var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });
/******/ 			}
/******/ 			def['default'] = function() { return value; };
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	!function() {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = function(chunkId) {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "js/async/" + chunkId + ".chunk.js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	!function() {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "hdbt:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = function(url, done, key, chunkId) {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = function(prev, event) {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach(function(fn) { return fn(event); });
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"nav-toggle": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = function(chunkId, promises) {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = function(event) {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkhdbt"] = self["webpackChunkhdbt"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/nav-toggle.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=nav-toggle.min.js.map